name: Deploy to Cloudflare

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy"
        required: true
        default: "production"
      deploy_method:
        description: "Deployment method"
        required: true
        default: "terraform"
        type: choice
        options:
          - terraform
          - wrangler

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Build frontend 
        run: npm run build
      
      - name: Compile TypeScript worker
        run: |
          # Install dependencies needed for compilation
          npm install -D @babel/parser @babel/types undici-types csstype pg-types pg-protocol
          
          # Create a dist directory for the worker
          mkdir -p dist
          
          # Compile TypeScript to JavaScript with the build config
          echo "Compiling server code to JavaScript..."
          npx tsc -p tsconfig.build.json
          
          # Use esbuild for the worker to ensure proper ESM format
          echo "Building module-format worker with esbuild..."
          npx esbuild dist/server/worker.js --format=esm --platform=neutral --bundle --outfile=worker-module.js
          
          # Verify the output has ESM format
          if ! grep -q "export default" worker-module.js; then
            echo "Error: Generated worker doesn't have ESM format, creating a fallback module..."
            # Create fallback test worker if compilation fails
            cat > worker-module.js << 'EOF'
            // Fallback module-format worker for Cloudflare
            // This uses proper ES Module syntax required for D1 bindings
            export default {
              async fetch(request, env, ctx) {
                try {
                  // Basic routing
                  const url = new URL(request.url);
                  
                  // Health check endpoint
                  if (url.pathname === '/health') {
                    return new Response('OK', { 
                      status: 200,
                      headers: { 'Content-Type': 'text/plain' }
                    });
                  }
                  
                  // Test D1 database connection
                  if (url.pathname === '/test-db') {
                    try {
                      // Simple test query to verify D1 connection
                      const result = await env.DB.prepare('SELECT 1 as test').first();
                      return new Response(JSON.stringify({
                        success: true,
                        dbTest: result?.test || null,
                        message: 'D1 connection successful'
                      }), {
                        status: 200,
                        headers: { 'Content-Type': 'application/json' }
                      });
                    } catch (dbError) {
                      return new Response(JSON.stringify({
                        success: false,
                        error: dbError.message,
                        message: 'D1 connection failed'
                      }), {
                        status: 500,
                        headers: { 'Content-Type': 'application/json' }
                      });
                    }
                  }
                  
                  return new Response(JSON.stringify({
                    success: true,
                    message: 'Module format worker is running correctly',
                    path: url.pathname,
                    time: new Date().toISOString()
                  }), {
                    status: 200,
                    headers: { 
                      'Content-Type': 'application/json',
                      'Access-Control-Allow-Origin': '*',
                      'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
                      'Access-Control-Allow-Headers': 'Content-Type'
                    }
                  });
                } catch (error) {
                  return new Response(JSON.stringify({
                    success: false,
                    error: error.message,
                  }), {
                    status: 500,
                    headers: { 'Content-Type': 'application/json' }
                  });
                }
              }
            };
            EOF
          fi
          
          echo "Worker file created successfully"

      - name: Setup Terraform
        if: github.event.inputs.deploy_method == 'terraform'
        uses: hashicorp/setup-terraform@v2
        with:
          cli_config_credentials_token: ${{ secrets.TF_API_TOKEN }}
      
      - name: Deploy with Terraform
        if: github.event.inputs.deploy_method == 'terraform'
        env:
          TF_VAR_cloudflare_api_token: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          TF_VAR_cloudflare_account_id: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          TF_VAR_neon_database_url: ${{ secrets.DATABASE_URL }}
        run: |
          cd terraform
          terraform init
          terraform apply -auto-approve
      
      - name: Deploy with Wrangler
        if: github.event.inputs.deploy_method == 'wrangler'
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
        run: |
          # Create a test D1 database if not exists
          if ! npx wrangler d1 list | grep -q "MTD_ITSA_DB"; then
            echo "Creating D1 database..."
            npx wrangler d1 create MTD_ITSA_DB
          fi
          
          # Get the database ID
          DB_ID=$(npx wrangler d1 list --json | grep -o '"uuid":"[^"]*"' | head -n 1 | cut -d':' -f2 | tr -d '"')
          echo "Using D1 database ID: $DB_ID"
          
          # Create a temporary wrangler config
          cat > wrangler-deploy.toml << EOF
          name = "mtd-itsa-prototype"
          main = "worker-module.js"
          compatibility_date = "2024-01-01"
          
          # Explicitly set to module format for D1 compatibility
          type = "javascript"
          format = "modules"
          
          # D1 database binding
          [[d1_databases]]
          binding = "DB"
          database_name = "MTD_ITSA_DB"
          database_id = "$DB_ID"
          EOF
          
          # Deploy with Wrangler
          echo "Deploying worker with Wrangler..."
          npx wrangler deploy --config wrangler-deploy.toml
          
      - name: Run Database Migrations
        if: github.ref == 'refs/heads/main'  # Only run migrations on main branch
        run: |
          npx wrangler d1 execute MTD_ITSA_DB --file=migrations/0000_initial_schema.sql
          npx wrangler d1 execute MTD_ITSA_DB --file=migrations/0001_sample_data.sql
        env:
          CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}